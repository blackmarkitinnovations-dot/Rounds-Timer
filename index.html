<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <!-- iOS: enables true fullscreen when launched from Home Screen -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Timer</title>

  <style>
/* =========================================================
   TIMER UI (clean baseline)
   - Keep edits in :root + the "EDIT HERE" blocks.
   ========================================================= */

/* ============ EDIT HERE: Theme ============ */
:root{
  --bg:#0b0c0f;
  --stroke:#242733;
  --stroke2:#2f3444;
  --text:#e9edf7;
  --muted:#a9b2c7;
  --red:#ff2b2b;
  --yellow:#ffd400;
  --green:#28d17c;
  --orange:#ff9a2a;
  --shadow: 0 16px 48px rgba(0,0,0,.45);
  --card: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
  --card2: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));

  /* iOS safe area */
  --sat: env(safe-area-inset-top);
  --sar: env(safe-area-inset-right);
  --sab: env(safe-area-inset-bottom);
  --sal: env(safe-area-inset-left);
}

/* ============ Base ============ */
*{ box-sizing:border-box; }
html, body{ height:100%; padding:0; overflow:hidden; }

body{
  position: fixed;
  inset: 0;
  margin:0;
  background: radial-gradient(1200px 600px at 50% 0%, #171a23 0%, var(--bg) 55%, #06070a 100%);
  color:var(--text);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  overflow:hidden;
  display:flex;
  align-items:stretch;
  justify-content:stretch;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

/* ============ App Shell ============ */
.app{
  max-width: 100vw;
  height: var(--apph, min(800px, 100vh));
  width: min(1280px, 100vw);
  margin: auto;
  border:1px solid var(--stroke);
  border-radius:24px;
  box-shadow: var(--shadow);
  overflow:hidden;
  background: var(--card);
  display:flex;
  flex-direction:column;
  position:relative;
}

/* On small screens: remove frame */
@media (max-width: 720px), (max-height: 720px){
  .app{
    width:100vw;
    height: var(--apph, 100dvh);
    max-height: var(--apph, 100dvh);
    border-radius:0;
    border:none;
    box-shadow:none;
    margin:0;
  }
}

/* ============ Header ============ */
header{
  height: clamp(52px, 8vh, 64px);
  display:flex;
  align-items:center;
  justify-content:center;
  border-bottom:1px solid var(--stroke);
  background: var(--card2);
  letter-spacing:.20em;
  font-weight:900;
  text-transform:uppercase;
  color:#dfe6ff;
  font-size: clamp(14px, 2.2vw, 20px);
  flex:0 0 auto;
  position:relative;
  padding-top: var(--sat);
  padding-left: var(--sal);
  padding-right: var(--sar);
}

.settingsBtn{
  position:absolute;
  left: calc(10px + var(--sal));
  top: calc(10px + var(--sat));
  width: clamp(36px, 6vw, 44px);
  height: clamp(36px, 6vw, 44px);
  border-radius:12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  user-select:none;
}
.settingsBtn:active{ transform: translateY(1px); filter: brightness(.95); }
.settingsBtn svg{ width: clamp(18px, 3.5vw, 22px); height: clamp(18px, 3.5vw, 22px); opacity:.92; }



/* Header icon group (Settings / Warnings / Presets) */
.headerIcons{
  position:absolute;
  left: calc(10px + var(--sal));
  top: calc(10px + var(--sat));
  display:flex;
  gap:8px;
  z-index: 3;
}
.iconBtn{
  width: clamp(36px, 6vw, 44px);
  height: clamp(36px, 6vw, 44px);
  border-radius:12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  user-select:none;
}
.iconBtn:active{ transform: translateY(1px); filter: brightness(.95); }
.iconBtn svg{ width: clamp(18px, 3.5vw, 22px); height: clamp(18px, 3.5vw, 22px); opacity:.92; }
.iconBtn.active{
  background: rgba(40,209,124,.18);
  border-color: rgba(40,209,124,.35);
}

/* ============ Top Controls ============ */
.topControls{
  height: clamp(64px, 10vh, 78px);
  flex:0 0 auto;
  border-bottom:1px solid var(--stroke);
  padding: clamp(10px, 1.6vw, 12px) clamp(10px, 1.8vw, 14px);
  display:flex;
  gap: clamp(8px, 1.4vw, 12px);
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
  padding-left: calc(clamp(10px, 1.8vw, 14px) + var(--sal));
  padding-right: calc(clamp(10px, 1.8vw, 14px) + var(--sar));
}

.btnRow{
  flex:1;
  padding: clamp(12px, 2.2vh, 16px) clamp(10px, 1.8vw, 14px);
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02));
  color:var(--text);
  font-weight:900;
  letter-spacing:.10em;
  text-transform:uppercase;
  cursor:pointer;
  user-select:none;
  font-size: clamp(13px, 2.2vw, 16px);
  transition: transform .06s ease, filter .15s ease;
  min-width: 0;
}
.btnRow:active{ transform: translateY(1px); filter:brightness(.95); }
.btnRow:disabled{ opacity:.45; cursor:not-allowed; }
.btnRow.green{ background: linear-gradient(180deg, rgba(40,209,124,.95), rgba(18,80,55,.65)); border-color: rgba(40,209,124,.35); }
.btnRow.orange{ background: linear-gradient(180deg, rgba(255,154,42,.95), rgba(94,54,15,.65)); border-color: rgba(255,154,42,.35); }
.btnRow.red{ background: linear-gradient(180deg, rgba(255,43,43,.95), rgba(95,18,18,.65)); border-color: rgba(255,43,43,.35); }

/* ============ Main Content ============ */
.content{
  flex: 1 1 auto;
  min-height:0;
  display:grid;
  grid-template-columns: minmax(240px, 320px) 1fr;
  gap: clamp(10px, 1.4vw, 14px);
  padding: clamp(10px, 1.4vw, 14px);
  overflow-y:auto;
  overflow-x:hidden;
  -webkit-overflow-scrolling: touch;
  padding-left: calc(clamp(10px, 1.4vw, 14px) + var(--sal));
  padding-right: calc(clamp(10px, 1.4vw, 14px) + var(--sar));
}

/* Full-width when left column hidden (JS toggles this class) */
.content.fullWidth{
  grid-template-columns: 1fr;
  gap: 0;
}
.content.fullWidth .leftCol{ display:none; }
.content.fullWidth .mainPanel{ width:100%; }

.leftCol{
  display:flex;
  flex-direction:column;
  gap: clamp(10px, 1.2vw, 12px);
  min-height:0;
  overflow:hidden;
}

.block{
  border:1px solid var(--stroke2);
  border-radius:18px;
  background: linear-gradient(180deg, rgba(255,255,255,.035), rgba(255,255,255,.012));
  overflow:hidden;
  display:flex;
  flex-direction:column;
  min-height:0;
}
.blockHeader{
  padding: 12px;
  border-bottom:1px solid rgba(255,255,255,.06);
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  font-weight:900;
  letter-spacing:.14em;
  text-transform:uppercase;
  font-size: 12px;
  color:var(--muted);
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}
.blockBody{
  padding: 12px;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:0;
  overflow:auto;
}

.btn{
  border:1px solid rgba(255,255,255,.10);
  border-bottom-color: rgba(0,0,0,.35);
  background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.02));
  color:var(--text);
  font-weight:900;
  text-transform:uppercase;
  letter-spacing:.08em;
  border-radius:14px;
  padding: 12px;
  font-size: 15px;
  cursor:pointer;
  user-select:none;
  transition: transform .06s ease, filter .15s ease;
  min-width:0;
}
.btn:active{ transform: translateY(1px); filter:brightness(.95); }

.warnRow{ display:flex; gap:10px; align-items:center; }
.warnBtn{ flex:1; padding:10px; font-size:13px; border-radius:12px; }

.switch{
  width:46px; height:26px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.25);
  cursor:pointer;
  position:relative;
  flex:0 0 auto;
  user-select:none;
}
.switch::after{
  content:"";
  position:absolute;
  top:3px; left:3px;
  width:20px; height:20px;
  border-radius:999px;
  background: linear-gradient(180deg, rgba(255,255,255,.85), rgba(255,255,255,.45));
  box-shadow: 0 10px 18px rgba(0,0,0,.35);
  transition:left .18s ease;
}
.switch.on{ background: rgba(40,209,124,.18); border-color: rgba(40,209,124,.35); }
.switch.on::after{ left:23px; }

/* Presets */

/* Dynamic presets */
.presetList{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.presetAddBtn{
  justify-content:center;
  gap:10px;
  opacity:.92;
}
.presetAddBtn .plus{
  font-size: 22px;
  line-height: 1;
}
.presetAddBtn .label{
  font-weight:900;
  letter-spacing:.10em;
  text-transform:uppercase;
  font-size: 14px;
  color: var(--text);
}
.presetBtnWrap{
  position:relative;
}
.presetBtn{
  width:100%;
  touch-action: pan-y; /* allow vertical scroll; we handle horizontal swipe */
  transition: transform .12s ease;
}

/* Layout fix: reserve space for swipe hint */
.presetBtn{
  padding-right: 120px;
}

.presetHint{
  position:absolute;
  right:12px;
  top: 78%;
  transform: translateY(-50%);
  font-size: 11px;
  letter-spacing:.10em;
  text-transform:uppercase;
  color: rgba(255,255,255,.55);
  pointer-events:none;
  opacity:.0;
  transition: opacity .12s ease;
  white-space: nowrap;
}
.presetBtnWrap.swipeable .presetHint{ opacity:.85; }

.presetGrid{
  display:grid;
  grid-template-columns: 1fr;
  gap:10px;
  min-height:0;
  overflow:auto;
  padding-right:2px;
}
.presetBtn{
  padding: 12px;
  border-radius:14px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.presetBtn .pname{
  font-weight:900;
  letter-spacing:.10em;
  font-size: clamp(18px, 4.5vw, 22px);
  white-space:nowrap;
}
.presetBtn .pmeta{
  font-size: clamp(12px, 2vw, 13px);
  color:var(--muted);
  letter-spacing:.06em;
  font-weight:800;
  text-transform:uppercase;
  white-space:nowrap;
}

/* Center Panel */
.mainPanel{
  border:1px solid var(--stroke);
  border-radius:18px;
  background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
  padding: clamp(6px, 1vw, 10px) clamp(10px, 1.6vw, 14px);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  position:relative;
  overflow:hidden;
  min-width:0;
}

.phasePill{
  position:absolute;
  top:10px; right:10px;
  padding:8px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.25);
  font-weight:900;
  letter-spacing:.12em;
  text-transform:uppercase;
  font-size:12px;
  color:var(--muted);
  z-index:2;
}
.phasePill.work{ color:#ffb3b3; border-color: rgba(255,43,43,.22); }
.phasePill.rest{ color:#ffeaa1; border-color: rgba(255,212,0,.22); }
.phasePill.paused{ color:#c8d6ff; border-color: rgba(140,170,255,.22); }
.phasePill.inf{ color:#d7ddff; border-color: rgba(170,190,255,.22); }

.bigTimer{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-weight:900;
  font-size: clamp(72px, 18vw, 220px);
  color:var(--red);
  line-height:0.94;
  letter-spacing:.05em;
  text-shadow: 0 10px 30px rgba(255,43,43,.22);
  margin:0;
  text-align:center;
  width:100%;
}

.divider{
  width: min(82%, 700px);
  height:3px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.6), transparent);
  border-radius:999px;
  margin: clamp(8px, 1.4vh, 12px) 0 clamp(6px, 1vh, 10px);
  flex:0 0 auto;
}

.roundRow{
  display:flex;
  align-items:baseline;
  justify-content:center;
  gap: clamp(10px, 2vw, 18px);
  text-transform:uppercase;
  font-weight:900;
  letter-spacing:.14em;
  margin: clamp(6px, 1vh, 10px) 0;
  flex:0 0 auto;
  flex-wrap: wrap;
  text-align:center;
}
.roundRow .label{ color:#fff; opacity:.95; font-size: clamp(18px, 2.8vw, 34px); }
.roundRow .value{ color:#fff; font-size: clamp(44px, 6.5vw, 84px); }
@media (max-width: 480px){
  .roundRow{ gap: 8px; }
  .roundRow .label{ font-size: 16px; }
  .roundRow .value{ font-size: 36px; }
}
.struck{ text-decoration: line-through; opacity:.55; }

.smallTimer{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-weight:900;
  font-size: clamp(48px, 14vw, 148px);
  color:var(--yellow);
  line-height:0.98;
  letter-spacing:.05em;
  text-shadow: 0 10px 30px rgba(255,212,0,.18);
  margin:0;
  text-align:center;
  width:100%;
}
.smallTimer.dim{ opacity:.35; }

/* ============ Footer ============ */
footer{
  height: clamp(64px, 10vh, 78px);
  flex:0 0 auto;
  position: relative;
  z-index: 5;
  border-top:1px solid var(--stroke);
  padding: clamp(10px, 1.6vw, 12px) clamp(10px, 1.8vw, 14px);
  display:flex;
  gap: clamp(8px, 1.4vw, 12px);
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
  padding-bottom: calc(clamp(10px, 1.6vw, 12px) + var(--sab));
  padding-left: calc(clamp(10px, 1.8vw, 14px) + var(--sal));
  padding-right: calc(clamp(10px, 1.8vw, 14px) + var(--sar));
}
.bottomBtn{
  flex:1;
  padding: clamp(12px, 2.2vh, 16px) clamp(10px, 1.8vw, 14px);
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02));
  color:var(--text);
  font-weight:900;
  letter-spacing:.10em;
  text-transform:uppercase;
  cursor:pointer;
  user-select:none;
  font-size: clamp(13px, 2.2vw, 16px);
  transition: transform .06s ease, filter .15s ease;
  min-width:0;
}
.bottomBtn:active{ transform: translateY(1px); filter:brightness(.95); }

/* Phone layout: stack left column under main timers */
@media (max-width: 780px){
  .content{ grid-template-columns: 1fr; }
  .blockHeader{ padding:10px 12px; }
  .blockBody{ padding:10px 12px; }
}

/* iPhone landscape: tighten so timers & footer fit */
@media (orientation: landscape) and (max-width: 950px){
  header{ height: 42px; font-size: 13px; }
  .topControls, footer{ height: 50px; padding: 6px; }
  .content{
    padding: 6px !important;
    grid-template-columns: minmax(220px, 280px) 1fr;
    gap: 8px;
  }
  .mainPanel{
    padding: 6px 10px !important;
    justify-content: space-evenly !important;
    overflow: visible !important;
  }
  .phasePill{ top: 6px; right: 8px; padding: 6px 8px; font-size: 11px; }
  .bigTimer{ font-size: clamp(46px, 13vw, 104px); line-height: 0.90; margin-top: 2px; }
  .divider{ margin: 6px 0 4px; height: 2px; }
  .roundRow{ margin: 4px 0; gap: 10px; }
  .roundRow .label{ font-size: clamp(14px, 2.5vw, 22px); }
  .roundRow .value{ font-size: clamp(22px, 5.5vw, 44px); }
  .smallTimer{ font-size: clamp(28px, 9vw, 64px); line-height: 0.92; margin-bottom: 2px; }
  .leftCol{ overflow: hidden; }
  .leftCol .blockBody{ overflow: auto; }
}

/* Small phone portrait: prevent timer text overflow sideways */
@media (max-width: 520px) and (orientation: portrait){
  .mainPanel{ padding-left: 8px !important; padding-right: 8px !important; }
  .bigTimer, .smallTimer{ width: 100%; white-space: nowrap; letter-spacing: .02em; }
}

/* ============ Modals ============ */
.modalBackdrop, .settingsBackdrop{
  position:fixed;
  inset:0;
  background:#0b0c0f;
  display:none;
  align-items:center;
  justify-content:center;
  padding:16px;
  z-index:50;
}
.modalBackdrop.show{ display:flex; }
.settingsBackdrop{ z-index:60; }
.settingsBackdrop.show{ display:flex; }

.modal{
  width:min(520px, 92vw);
  border-radius:22px;
  background:#141826;
  border:1px solid var(--stroke);
  box-shadow: var(--shadow);
  overflow:hidden;
}
.modalHeader{
  padding:14px 16px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  border-bottom:1px solid var(--stroke);
  background:#111522;
  gap:10px;
}
.modalHeader .title{
  font-weight:900;
  text-transform:uppercase;
  letter-spacing:.14em;
  font-size:13px;
  color:#dfe6ff;
}
.modalHeader .hint{ font-size:12px; color:var(--muted); }
.entry{
  padding:14px 16px;
  display:flex;
  align-items:center;
  justify-content:center;
  border-bottom:1px solid var(--stroke);
  background:#0e111b;
}
.entryValue{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-weight:900;
  font-size: clamp(34px, 7vw, 44px);
  letter-spacing:.08em;
  color:#fff;
}
.pad{
  padding:14px 16px 16px;
  display:grid;
  grid-template-columns: repeat(3, 1fr);
  gap:10px;
  background:#141826;
}
.key{
  padding:16px 0;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02));
  font-weight:900;
  font-size: clamp(20px, 5vw, 26px);
  color:var(--text);
  cursor:pointer;
  user-select:none;
}
.key:active{ transform: translateY(1px); filter:brightness(.95); }
.key.wide{ grid-column: span 2; }
.key.actionEnter{
  background: linear-gradient(180deg, rgba(40,209,124,.95), rgba(18,80,55,.65));
  border-color: rgba(40,209,124,.35);
  text-transform:uppercase;
  letter-spacing:.1em;
  font-size: clamp(14px, 3.2vw, 18px);
}
.key.actionCancel{
  background: linear-gradient(180deg, rgba(255,154,42,.95), rgba(94,54,15,.65));
  border-color: rgba(255,154,42,.35);
  text-transform:uppercase;
  letter-spacing:.1em;
  font-size: clamp(14px, 3.2vw, 18px);
}
.key.actionAlt{
  background: linear-gradient(180deg, rgba(140,170,255,.55), rgba(50,70,140,.35));
  border-color: rgba(140,170,255,.35);
  text-transform:uppercase;
  letter-spacing:.1em;
  font-size: clamp(14px, 3.2vw, 18px);
}

/* Settings modal */
.settingsModal{
  width:min(860px, 96vw);
  height:min(640px, 92vh);
  border-radius:22px;
  background:#141826;
  border:1px solid var(--stroke);
  box-shadow: var(--shadow);
  overflow:hidden;
  display:flex;
  flex-direction:column;
}
.settingsTop{
  padding:14px 16px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  border-bottom:1px solid var(--stroke);
  background:#111522;
  gap:10px;
}
.settingsTop .title{
  font-weight:900;
  letter-spacing:.18em;
  text-transform:uppercase;
  font-size:14px;
  color:#dfe6ff;
}
.settingsClose{
  border-radius:12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color:#fff;
  font-weight:900;
  padding:10px 12px;
  cursor:pointer;
  text-transform:uppercase;
  letter-spacing:.12em;
  font-size:12px;
  white-space:nowrap;
}
.settingsClose:active{ transform: translateY(1px); filter:brightness(.95); }

.settingsBody{
  padding:16px;
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap:14px;
  overflow:auto;
}
@media (max-width: 900px){
  .settingsBody{ grid-template-columns: 1fr; }
  .settingsModal{ height: min(740px, 92vh); }
}
.setCard{
  border:1px solid rgba(255,255,255,.10);
  border-radius:18px;
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  padding:14px;
  min-width:0;
}
.setCard h3{
  margin:0 0 10px 0;
  font-size:12px;
  color:var(--muted);
  text-transform:uppercase;
  letter-spacing:.16em;
  font-weight:900;
}
.row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:10px 0;
  border-bottom:1px solid rgba(255,255,255,.06);
  min-width:0;
}
.row:last-child{ border-bottom:none; }
.row .label{
  font-weight:900;
  letter-spacing:.06em;
  text-transform:uppercase;
  font-size:12px;
  color:#e9edf7;
  white-space:nowrap;
}
.row .value{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  color:var(--muted);
  font-weight:900;
  font-size:12px;
  letter-spacing:.08em;
  min-width:64px;
  text-align:right;
  white-space:nowrap;
}
.settingsBody input[type="range"]{ width:100%; min-width:0; }

/* ============ Toast + Helpers ============ */
.toast{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  bottom: calc(18px + var(--sab));
  background: rgba(20,24,38,.95);
  border:1px solid rgba(255,255,255,.10);
  color:#fff;
  padding:10px 14px;
  border-radius:999px;
  font-weight:900;
  letter-spacing:.08em;
  text-transform:uppercase;
  font-size:12px;
  box-shadow: 0 14px 30px rgba(0,0,0,.35);
  opacity:0;
  pointer-events:none;
  transition: opacity .18s ease;
  z-index:80;
}
.toast.show{ opacity:1; }
.hidden{ display:none !important; }


/* =========================
   UTILITY CLASSES (modifiers)
   Keep markup clean: apply these as needed.
   ========================= */
.growMin0{ flex:1; min-height:0; }
.pad10{ padding:10px !important; }
.labelSlash{ opacity:.55; letter-spacing:.08em; font-weight:800; }
.valueMuted{ opacity:.8; }
.fullRow{ grid-column: 1 / -1; }
.btnRowEnd{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
.testBtnClack{ background:rgba(140,170,255,.12); }
.testBtnBuzz{ background:rgba(255,212,0,.12); }


/* Scrollbar polish */
html, body{
  overflow-x: hidden;
}

.content{
  overflow-x: hidden;
}

/* Hide scrollbar visuals (WebKit) */
.content::-webkit-scrollbar{
  height: 0;
}

/* Firefox */
.content{
  scrollbar-width: none;
}


/* HARD scrollbar kill (no horizontal bleed anywhere) */
*{
  max-width: 100%;
}

.app,
.content,
.leftCol,
.block,
.blockBody,
.presetGrid,
.presetList{
  overflow-x: hidden !important;
}

/* Hide scrollbar visuals everywhere but keep vertical scroll */
*::-webkit-scrollbar{
  width: 0;
  height: 0;
}

*{
  scrollbar-width: none;
}

</style>
</head>

<body>
  <div class="app">
    <header>

<div class="headerIcons" aria-label="Top left controls">
  <!-- Settings -->
  <div class="iconBtn" id="openSettings" title="Settings" role="button" tabindex="0" aria-label="Open settings">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
         stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <circle cx="12" cy="12" r="3"></circle>
      <path d="M19.4 15a7.9 7.9 0 0 0 .1-1l2-1.5-2-3.5-2.4.6a8 8 0 0 0-1.7-1L14 2h-4l-.4 2.6a8 8 0 0 0-1.7 1L5.5 5 3.5 8.5 5.5 10a7.9 7.9 0 0 0 0 2L3.5 13.5 5.5 17l2.4-.6a8 8 0 0 0 1.7 1L10 22h4l.4-2.6a8 8 0 0 0 1.7-1l2.4.6 2-3.5-2-1.5z"></path>
    </svg>
  </div>

  <!-- Warnings -->
  <div class="iconBtn" id="toggleWarningsIcon" title="Warnings" role="button" tabindex="0" aria-label="Toggle warnings panel">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
         stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <path d="M10.3 3.2 1.9 18a2 2 0 0 0 1.7 3h16.8a2 2 0 0 0 1.7-3L13.7 3.2a2 2 0 0 0-3.4 0z"></path>
      <path d="M12 9v4"></path>
      <path d="M12 17h.01"></path>
    </svg>
  </div>

  <!-- Presets -->
  <div class="iconBtn" id="togglePresetsIcon" title="Presets" role="button" tabindex="0" aria-label="Toggle presets panel">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
         stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <path d="M12 2l2.9 6 6.6.6-5 4.2 1.5 6.4L12 16.9 6 19.2l1.4-6.4-5-4.2L9.1 8z"></path>
    </svg>
  </div>
</div>
Timer
    </header>

    <div class="topControls">
      <button class="btnRow green" id="btnStart">Start</button>
      <button class="btnRow orange" id="btnPause">Pause</button>
      <button class="btnRow red" id="btnReset">Reset</button>
    </div>

    <div class="content">
      <aside class="leftCol" id="leftCol">
        <section class="block" id="warningsBlock">
          <div class="blockHeader"><span>Warnings</span></div>
          <div class="blockBody">
            <div class="warnRow">
              <button class="btn warnBtn" id="btnStartWarn">Start Warn</button>
              <div class="switch" id="toggleStartWarn" role="switch" aria-checked="false" tabindex="0"></div>
            </div>
            <div class="warnRow">
              <button class="btn warnBtn" id="btnEndWarn">End Warn</button>
              <div class="switch" id="toggleEndWarn" role="switch" aria-checked="false" tabindex="0"></div>
            </div>
          </div>
        </section>

        <section class="block growMin0" id="presetsBlock">
          <div class="blockHeader">Presets</div>
          <div class="blockBody pad10">
            <div class="presetGrid">
              
              <div id="presetList" class="presetList"></div>

              <button class="btn presetAddBtn" id="addPresetBtn" type="button" aria-label="Add preset">
                <span class="plus">＋</span>
                <span class="label">Add Preset</span>
              </button>
</div>
          </div>
        </section>
      </aside>

      <main class="mainPanel">
        <div class="phasePill work" id="phasePill">WORK</div>

        <div class="bigTimer" id="workDisplay">05:00</div>
        <div class="divider"></div>

        <div class="roundRow">
          <div class="label" id="roundLabel">ROUND</div>
          <div class="value" id="roundDisplay">1</div>
          <div class="label labelSlash" id="slashLabel">/</div>
          <div class="value valueMuted" id="roundTotalDisplay">8</div>
        </div>

        <div class="smallTimer" id="restDisplay">00:30</div>
      </main>
    </div>

    <footer>
      <button class="bottomBtn" id="setWork">Work</button>
      <button class="bottomBtn" id="setRest">Rest</button>
      <button class="bottomBtn" id="setRounds">Rounds</button>
    </footer>
  </div>

  <!-- keypad -->
  <div class="modalBackdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modalHeader">
        <div>
          <div class="title" id="modalTitle">SET WORK</div>
          <div class="hint" id="modalHint"></div>
        </div>
        <div class="hint" id="currentConfig"></div>
      </div>

      <div class="entry">
        <div class="entryValue" id="entryValue">00:00</div>
      </div>

      <div class="pad" id="pad">
        <button class="key" data-k="1">1</button>
        <button class="key" data-k="2">2</button>
        <button class="key" data-k="3">3</button>

        <button class="key" data-k="4">4</button>
        <button class="key" data-k="5">5</button>
        <button class="key" data-k="6">6</button>

        <button class="key" data-k="7">7</button>
        <button class="key" data-k="8">8</button>
        <button class="key" data-k="9">9</button>

        <button class="key actionAlt" data-k="infinite">Infinite</button>
        <button class="key" data-k="0">0</button>
        <button class="key actionAlt" data-k="clear">Clear</button>

        <button class="key actionCancel wide" data-k="cancel">Cancel</button>
        <button class="key actionEnter" data-k="enter">Enter</button>
      </div>
    </div>
  </div>

  <!-- settings page -->
  <div class="settingsBackdrop" id="settingsBackdrop" aria-hidden="true">
    <div class="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="settingsTop">
        <div class="title" id="settingsTitle">Settings</div>
        <button class="settingsClose" id="closeSettings">Close</button>
      </div>

      <div class="settingsBody">
        <div class="setCard">
          <h3>Clap / Clack</h3>

          <div class="row">
            <div class="label">Volume</div>
            <input type="range" id="clapVol" min="0" max="3" step="0.01" />
            <div class="value" id="clapVolVal"></div>
          </div>

          <div class="row">
            <div class="label">Speed (interval)</div>
            <input type="range" id="clapInterval" min="0.03" max="0.25" step="0.01" />
            <div class="value" id="clapIntervalVal"></div>
          </div>
        </div>

        <div class="setCard">
          <h3>Buzzer</h3>

          <div class="row">
            <div class="label">Volume</div>
            <input type="range" id="buzzVol" min="0" max="1" step="0.01" />
            <div class="value" id="buzzVolVal"></div>
          </div>

          <div class="row">
            <div class="label">Duration (ms)</div>
            <input type="range" id="buzzDur" min="100" max="1500" step="25" />
            <div class="value" id="buzzDurVal"></div>
          </div>
        </div>

        <div class="setCard fullRow">
          <h3>Display</h3>

          

          

          <div class="row">
            <div class="label">Test Sounds</div>
            <div class="btnRowEnd">
              <button class="settingsClose testBtn testBtnClack" id="testClack">Test Clap</button>
              <button class="settingsClose testBtn testBtnBuzz" id="testBuzz">Test Buzzer</button>
            </div>
            <div class="value"></div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <div class="flashOverlay" id="flashOverlay" aria-hidden="true"></div>

  <script>
    // ============================================================
    // HARDENING: tolerate missing DOM blocks during iterative edits
    // ============================================================
    window.addEventListener("error", (e) => {
      // Keep UI alive during layout refactors; check DevTools console for details.
      console.error("UI error:", e.error || e.message);
    });

    /* ============================================================
       TIMER UI SCRIPT
       - Split into clear sections for safe iteration.
       - Prefer editing values in the EDIT HERE blocks.
       ============================================================ */
    /* ============================================================
       VIEWPORT / SAFE AREA
       ============================================================ */
    // Keeps the UI sized to the *visible* viewport so the Safari toolbars don't cover timers/buttons.
    (function(){
      function setAppHeight(){
        const vv = window.visualViewport;
        const h = vv ? Math.round(vv.height) : window.innerHeight;
        document.documentElement.style.setProperty("--apph", h + "px");
      }
      setAppHeight();
      window?.addEventListener("resize", setAppHeight, {passive:true});
      window?.addEventListener("orientationchange", () => setTimeout(setAppHeight, 50), {passive:true});
      if (window.visualViewport){
        window.visualViewport.addEventListener("resize", setAppHeight, {passive:true});
        window.visualViewport.addEventListener("scroll", setAppHeight, {passive:true});
      }
    })();

    /* ============================================================
       SETTINGS STORAGE
       ============================================================ */
    const SETTINGS_KEY = "hiit_settings_v4_responsive";
    const defaultSettings = {
      clapVolume: 1.0,
      clapInterval: 0.20,
      clapCount: 4,
      buzzVolume: 0.35,
      buzzDurationMs: 525,
      showWarnings: true,
      showPresets: true
    };

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    function loadSettings(){
      try{
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) return { ...defaultSettings };
        const s = JSON.parse(raw);
        return {
          clapVolume: typeof s.clapVolume === "number" ? clamp(s.clapVolume,0,3) : defaultSettings.clapVolume,
          clapInterval: typeof s.clapInterval === "number" ? clamp(s.clapInterval,0.03,0.25) : defaultSettings.clapInterval,
          clapCount: typeof s.clapCount === "number" ? clamp(s.clapCount,1,8) : defaultSettings.clapCount,
          buzzVolume: typeof s.buzzVolume === "number" ? clamp(s.buzzVolume,0,1) : defaultSettings.buzzVolume,
          buzzDurationMs: typeof s.buzzDurationMs === "number" ? clamp(s.buzzDurationMs,100,1500) : defaultSettings.buzzDurationMs,
          showWarnings: typeof s.showWarnings === "boolean" ? s.showWarnings : defaultSettings.showWarnings,
          showPresets: typeof s.showPresets === "boolean" ? s.showPresets : defaultSettings.showPresets
        };
      }catch{
        return { ...defaultSettings };
      }
    }
    function saveSettings(){
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    }
    let settings = loadSettings();

    /* ============================================================
       WAKE LOCK
       ============================================================ */
    // Works on most modern Chrome/Edge/Android; iOS Safari support is limited.
    let wakeLock = null;

    async function requestWakeLock(){
      try{
        if (!("wakeLock" in navigator)) return;
        if (wakeLock) return; // already held
        wakeLock = await navigator.wakeLock.request("screen");
        wakeLock?.addEventListener("release", () => { wakeLock = null; });
      }catch{
        // ignore (permission, unsupported, etc.)
      }
    }

    async function releaseWakeLock(){
      try{
        if (wakeLock){
          await wakeLock.release();
          wakeLock = null;
        }
      }catch{
        // ignore
      }
    }

    document?.addEventListener("visibilitychange", () => {
      // If the page comes back visible while running, try to re-acquire.
      if (document.visibilityState === "visible"){
        if (state && state.running && !state.paused){
          requestWakeLock();
        }
      } else {
        // Release when hidden to avoid errors; browser will drop it anyway.
        releaseWakeLock();
      }
    });

    /* ============================================================
       UTILITIES
       ============================================================ */
    function fmtMMSS_Countdown(ms){
      ms = Math.max(0, Math.round(ms));
      const totalSec = Math.ceil(ms / 1000);
      const mm = Math.floor(totalSec / 60);
      const ss = totalSec % 60;
      return String(mm).padStart(2,'0') + ':' + String(ss).padStart(2,'0');
    }
    function fmtMMSS_FromSeconds(sec){
      sec = Math.max(0, Math.floor(sec));
      const mm = Math.floor(sec / 60);
      const ss = sec % 60;
      return String(mm).padStart(2,'0') + ':' + String(ss).padStart(2,'0');
    }
    function mmssDigitsToMs(digits){
      const d = digits.padStart(4,'0').slice(-4);
      const mm = parseInt(d.slice(0,2), 10);
      const ss = clamp(parseInt(d.slice(2,4), 10), 0, 59);
      return (mm * 60 + ss) * 1000;
    }
    function msToMMSSDigits(ms){
      const totalSec = Math.max(0, Math.round(ms / 1000));
      const mm = Math.floor(totalSec / 60);
      const ss = totalSec % 60;
      return String(mm).padStart(2,'0') + String(ss).padStart(2,'0');
    }

    /* ============================================================
       AUDIO COMPATIBILITY
       ============================================================ */
    function vibratePattern(pattern){
      if ("vibrate" in navigator){
        try{ navigator.vibrate(pattern); }catch(e){}
      }
    }
    function flashScreen(times=1){
      const el = document.getElementById("flashOverlay");
      if (!el) return;
      let i = 0;
      const flashOnce = () => {
        el?.classList.add("show");
        setTimeout(() => el?.classList.remove("show"), 60);
        i++;
        if (i < times) setTimeout(flashOnce, 120);
      };
      flashOnce();
    }

    /* ============================================================
       AUDIO
       ============================================================ */
    let audioCtx = null;
    let audioUnlocked = false;

    function ensureAudio(){
      if (!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === "suspended"){
        audioCtx.resume().catch(()=>{});
      }
    }
    function unlockAudio(){
      ensureAudio();
      if (!audioCtx || audioUnlocked) return;
      const t0 = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(500, t0);
      g.gain.setValueAtTime(0.00001, t0);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(t0);
      osc.stop(t0 + 0.02);
      audioUnlocked = true;
    }
    function userTapAudioPrime(){
      unlockAudio();
      ensureAudio();
    }

    function makeSoftClipCurve(amount){
      const n = 44100;
      const curve = new Float32Array(n);
      for (let i=0;i<n;i++){
        const x = (i/(n-1))*2 - 1;
        curve[i] = Math.tanh(x / amount);
      }
      return curve;
    }

    function buzzer({durationMs, freqHz=500, gain} = {}){
      vibratePattern([200,100,200]);
      flashScreen(1);
      ensureAudio();
      if (!audioCtx || audioCtx.state !== "running") return;

      const dur = (typeof durationMs === "number") ? durationMs : settings.buzzDurationMs;
      const gLevel = (typeof gain === "number") ? gain : settings.buzzVolume;

      const t0 = audioCtx.currentTime;
      const t1 = t0 + dur/1000;

      const osc = audioCtx.createOscillator();
      osc.type = "square";
      osc.frequency.setValueAtTime(freqHz, t0);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gLevel, t0 + 0.015);

      const chopHz = 25, step = 1 / chopHz;
      let on = true;
      for (let t = t0; t < t1; t += step){
        g.gain.setValueAtTime(on ? gLevel : gLevel * 0.12, t);
        on = !on;
      }
      g.gain.exponentialRampToValueAtTime(0.0001, t1);

      const len = Math.floor(audioCtx.sampleRate * (dur/1000));
      const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<len;i++) data[i] = (Math.random()*2 - 1) * 0.25;

      const noise = audioCtx.createBufferSource();
      noise.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(1400, t0);
      bp.Q.setValueAtTime(0.8, t0);

      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(gLevel * 0.22, t0);

      const mix = audioCtx.createGain();
      osc.connect(mix);
      noise.connect(bp); bp.connect(ng); ng.connect(mix);

      mix.connect(g);
      g.connect(audioCtx.destination);

      osc.start(t0);
      noise.start(t0);
      osc.stop(t1 + 0.02);
      noise.stop(t1 + 0.02);
    }

    function clampClick(atTime){
      const t0 = atTime;
      const VOL = settings.clapVolume;

      const dur = 0.045;
      const len = Math.floor(audioCtx.sampleRate * dur);

      const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
      const data = buf.getChannelData(0);

      for (let i=0;i<len;i++){
        const x = i / len;
        const env = Math.pow(1 - x, 2.2);
        data[i] = (Math.random()*2 - 1) * env;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(3200, t0);
      bp.Q.setValueAtTime(1.4, t0);

      const osc = audioCtx.createOscillator();
      osc.type = "square";
      osc.frequency.setValueAtTime(2400, t0);

      const og = audioCtx.createGain();
      og.gain.setValueAtTime(0.0001, t0);
      og.gain.exponentialRampToValueAtTime(0.45 * VOL, t0 + 0.002);
      og.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.018);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(1.10 * VOL, t0 + 0.003);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      noise.connect(bp).connect(g);
      osc.connect(og);

      const mix = audioCtx.createGain();
      g.connect(mix);
      og.connect(mix);

      const shaper = audioCtx.createWaveShaper();
      shaper.curve = makeSoftClipCurve(0.85);
      shaper.oversample = "4x";

      const out = audioCtx.createGain();
      out.gain.setValueAtTime(1.35, t0);

      mix.connect(shaper).connect(out).connect(audioCtx.destination);

      noise.start(t0);
      noise.stop(t0 + dur + 0.02);
      osc.start(t0);
      osc.stop(t0 + 0.03);
    }

    function clacksN(){
      vibratePattern([80,60,80,60,80]);
      flashScreen(settings.clapCount || 3);
      ensureAudio();
      if (!audioCtx || audioCtx.state !== "running") return;
      const t0 = audioCtx.currentTime + 0.01;
      const interval = settings.clapInterval;
      const count = settings.clapCount;
      for (let i=0;i<count;i++){
        clampClick(t0 + i * interval);
      }
    }

    /* ============================================================
       APP STATE
       ============================================================ */
    // =========================================================
    // EDIT HERE: Default timer values (applies on page load / reset)
    // =========================================================
    // state.workMs      = work duration in milliseconds (e.g. 5*60*1000)
    // state.restMs      = rest duration in milliseconds (e.g. 30*1000)
    // state.totalRounds = total rounds (1–99)
    // state.startWarnMs / endWarnMs = warning trigger times (ms remaining)
    // =========================================================

    const state = {
      workMs: 5 * 60 * 1000,
      restMs: 30 * 1000,
      totalRounds: 8,
      workInfinite: false,
      roundsInfinite: false,

      // Start Warn -> REST, End Warn -> WORK
      startWarnEnabled: false,
      endWarnEnabled: false,
      startWarnMs: 10 * 1000,
      endWarnMs: 10 * 1000,

      phase: "work",
      running: false,
      paused: false,
      currentRound: 1,
      remainingWorkMs: 5 * 60 * 1000,
      remainingRestMs: 30 * 1000,
      workElapsedSec: 0,

      buzzedZeroThisPhase: false,
      firedStartWarnThisPhase: false,
      firedEndWarnThisPhase: false,

      keypadOpen: false,
      keypadTarget: null,
      keypadDigits: "",

      settingsOpen: false
    };

    /* ============================================================
       PRESETS
       ============================================================ */
    const PRESET_KEY = "hiit_presets_v5";
    const defaultPreset = { workMs: 0, restMs: 0, rounds: 0, roundsInfinite:false, workInfinite:false };
function loadPresets(){
      try{
        const raw = localStorage.getItem(PRESET_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr) || arr.length < 1) return [];
        return arr.map(p => ({
          workMs: typeof p.workMs === "number" ? p.workMs : 0,
          restMs: typeof p.restMs === "number" ? p.restMs : 0,
          rounds: typeof p.rounds === "number" ? p.rounds : 0,
          roundsInfinite: !!p.roundsInfinite,
          workInfinite: !!p.workInfinite
        }));
      }catch{
        return [];
      }
    }
    function savePresets(p){ localStorage.setItem(PRESET_KEY, JSON.stringify(p)); }
    let presets = loadPresets();

    /* ============================================================
       DOM REFERENCES
       ============================================================ */
    const contentEl = document.querySelector(".content");
    const workDisplay = document.getElementById("workDisplay");
    const restDisplay = document.getElementById("restDisplay");
    const roundDisplay = document.getElementById("roundDisplay");
    const roundTotalDisplay = document.getElementById("roundTotalDisplay");
    const phasePill = document.getElementById("phasePill");

    const btnStart = document.getElementById("btnStart");
    const btnPause = document.getElementById("btnPause");
    const btnReset = document.getElementById("btnReset");

    const setWork = document.getElementById("setWork");
    const setRest  = document.getElementById("setRest");
    const setRounds= document.getElementById("setRounds");

    const btnStartWarn = document.getElementById("btnStartWarn");
    const btnEndWarn = document.getElementById("btnEndWarn");
    const toggleStartWarn = document.getElementById("toggleStartWarn");
    const toggleEndWarn = document.getElementById("toggleEndWarn");

    const warningsBlock = document.getElementById("warningsBlock");
    const presetsBlock = document.getElementById("presetsBlock");

    

    const presetList = document.getElementById("presetList");
    const addPresetBtn = document.getElementById("addPresetBtn");
const modalBackdrop = document.getElementById("modalBackdrop");
    const modalTitle = document.getElementById("modalTitle");
    const modalHint = document.getElementById("modalHint");
    const entryValue = document.getElementById("entryValue");
    const currentConfig = document.getElementById("currentConfig");
    const pad = document.getElementById("pad");

    const openSettingsBtn = document.getElementById("openSettings");
    const toggleWarningsIcon = document.getElementById("toggleWarningsIcon");
    const togglePresetsIcon  = document.getElementById("togglePresetsIcon");
    const settingsBackdrop = document.getElementById("settingsBackdrop");
    const closeSettingsBtn = document.getElementById("closeSettings");
const testClack = document.getElementById("testClack");
    const testBuzz = document.getElementById("testBuzz");

    const clapVol = document.getElementById("clapVol");
    const clapVolVal = document.getElementById("clapVolVal");
    const clapInterval = document.getElementById("clapInterval");
    const clapIntervalVal = document.getElementById("clapIntervalVal");

    const buzzVol = document.getElementById("buzzVol");
    const buzzVolVal = document.getElementById("buzzVolVal");
    const buzzDur = document.getElementById("buzzDur");
    const buzzDurVal = document.getElementById("buzzDurVal");

    const toast = document.getElementById("toast");
/* ============================================================
       TOAST / NOTICES
       ============================================================ */
    let toastTimer = null;
    function showToast(text){
      if (toast) toast.textContent = text;
      toast?.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toast?.classList.remove("show"), 900);
    }

    /* ============================================================
       RESET / FACTORY DEFAULTS
       ============================================================ */
    function resetPhaseGuards(){
      state.buzzedZeroThisPhase = false;
      state.firedStartWarnThisPhase = false;
      state.firedEndWarnThisPhase = false;
    }
    function resetRunState(){
      releaseWakeLock();
      state.phase = "work";
      state.currentRound = 1;
      state.running = false;
      state.paused = false;

      state.workElapsedSec = 0;
      state.remainingWorkMs = state.workMs;
      state.remainingRestMs = state.restMs;

      resetPhaseGuards();
    }

    /* ============================================================
       WARNINGS
       ============================================================ */
    function maybeFireWorkWarning(beforeMs, afterMs){
      if (!state.endWarnEnabled || state.firedEndWarnThisPhase || state.endWarnMs <= 0) return;
      if (beforeMs > state.endWarnMs && afterMs <= state.endWarnMs){
        state.firedEndWarnThisPhase = true;
        clacksN();
      }
    }
    function maybeFireRestWarning(beforeMs, afterMs){
      if (!state.startWarnEnabled || state.firedStartWarnThisPhase || state.startWarnMs <= 0) return;
      if (beforeMs > state.startWarnMs && afterMs <= state.startWarnMs){
        state.firedStartWarnThisPhase = true;
        clacksN();
      }
    }
    function checkImmediatePhaseWarnings(){
      if (state.workInfinite) return;
      if (state.phase === "work"){
        if (state.endWarnEnabled && !state.firedEndWarnThisPhase && state.endWarnMs > 0 && state.endWarnMs >= state.remainingWorkMs){
          state.firedEndWarnThisPhase = true;
          clacksN();
        }
      } else {
        if (state.startWarnEnabled && !state.firedStartWarnThisPhase && state.startWarnMs > 0 && state.startWarnMs >= state.remainingRestMs){
          state.firedStartWarnThisPhase = true;
          clacksN();
        }
      }
    }

    /* ============================================================
       KEYPAD
       ============================================================ */
    function renderKeypad(){
      if (!state.keypadOpen) return;
      const show = (ms) => fmtMMSS_Countdown(ms);

      if (state.keypadTarget === "work"){
        if (modalTitle) modalTitle.textContent = "SET WORK";
        if (modalHint) modalHint.textContent = "Enter MMSS or tap Infinite";
        if (currentConfig) currentConfig.textContent = "Current: " + (state.workInfinite ? "∞" : show(state.workMs));
        const base = state.keypadDigits || msToMMSSDigits(state.workMs);
        if (entryValue) entryValue.textContent = state.workInfinite ? "∞" : show(mmssDigitsToMs(base));
      } else if (state.keypadTarget === "rest"){
        if (modalTitle) modalTitle.textContent = "SET REST";
        if (modalHint) modalHint.textContent = "Enter MMSS";
        if (currentConfig) currentConfig.textContent = "Current: " + show(state.restMs);
        const base = state.keypadDigits || msToMMSSDigits(state.restMs);
        if (entryValue) entryValue.textContent = show(mmssDigitsToMs(base));
      } else if (state.keypadTarget === "rounds"){
        if (modalTitle) modalTitle.textContent = "SET ROUNDS";
        if (modalHint) modalHint.textContent = "Enter 1–99 or tap Infinite";
        if (currentConfig) currentConfig.textContent = "Current: " + (state.roundsInfinite ? "∞" : state.totalRounds);
        if (entryValue) entryValue.textContent = state.roundsInfinite ? "∞" : (state.keypadDigits.length ? state.keypadDigits : String(state.totalRounds));
      } else if (state.keypadTarget === "startWarn"){
        if (modalTitle) modalTitle.textContent = "START WARN (REST)";
        if (modalHint) modalHint.textContent = "Clacks when REST remaining hits this";
        if (currentConfig) currentConfig.textContent = "Current: " + show(state.startWarnMs);
        const base = state.keypadDigits || msToMMSSDigits(state.startWarnMs);
        if (entryValue) entryValue.textContent = show(mmssDigitsToMs(base));
      } else if (state.keypadTarget === "endWarn"){
        if (modalTitle) modalTitle.textContent = "END WARN (WORK)";
        if (modalHint) modalHint.textContent = "Clacks when WORK remaining hits this";
        if (currentConfig) currentConfig.textContent = "Current: " + show(state.endWarnMs);
        const base = state.keypadDigits || msToMMSSDigits(state.endWarnMs);
        if (entryValue) entryValue.textContent = show(mmssDigitsToMs(base));
      }
    }

    function openKeypad(target){
      state.keypadOpen = true;
      state.keypadTarget = target;
      state.keypadDigits = "";
      renderKeypad();
      render();
    }
    function closeKeypad(){
      state.keypadOpen = false;
      state.keypadTarget = null;
      state.keypadDigits = "";
      render();
    }

    function applyKeypad(){
      const target = state.keypadTarget;

      if (target === "work"){
        if (!state.workInfinite){
          const ms = mmssDigitsToMs(state.keypadDigits || msToMMSSDigits(state.workMs));
          state.workMs = clamp(ms, 1000, (99*60 + 59) * 1000);
        }
      } else if (target === "rest"){
        const ms = mmssDigitsToMs(state.keypadDigits || msToMMSSDigits(state.restMs));
        state.restMs = clamp(ms, 0, (99*60 + 59) * 1000);
      } else if (target === "rounds"){
        if (!state.roundsInfinite){
          const n = parseInt(state.keypadDigits || String(state.totalRounds), 10);
          state.totalRounds = clamp(isNaN(n) ? state.totalRounds : n, 1, 99);
        }
      } else if (target === "startWarn"){
        const ms = mmssDigitsToMs(state.keypadDigits || msToMMSSDigits(state.startWarnMs));
        state.startWarnMs = clamp(ms, 0, (99*60 + 59) * 1000);
      } else if (target === "endWarn"){
        const ms = mmssDigitsToMs(state.keypadDigits || msToMMSSDigits(state.endWarnMs));
        state.endWarnMs = clamp(ms, 0, (99*60 + 59) * 1000);
      }

      resetRunState();
      closeKeypad();
    }

    function keypadPushDigit(d){
      if (state.keypadTarget === "work" && state.workInfinite) state.workInfinite = false;
      if (state.keypadTarget === "rounds" && state.roundsInfinite) state.roundsInfinite = false;

      if (state.keypadTarget === "rounds"){
        state.keypadDigits = (state.keypadDigits + d).slice(0, 2);
      } else {
        state.keypadDigits = (state.keypadDigits + d).slice(-4);
      }
      renderKeypad();
      render();
    }

    function keypadClear(){
      if (state.keypadTarget === "rounds"){
        state.keypadDigits = "";
      } else {
        state.keypadDigits = "0000";
      }
      renderKeypad();
      render();
    }

    function keypadInfinite(){
      if (state.keypadTarget === "work"){
        state.workInfinite = !state.workInfinite;
        state.keypadDigits = "";
      } else if (state.keypadTarget === "rounds"){
        state.roundsInfinite = !state.roundsInfinite;
        state.keypadDigits = "";
      }
      renderKeypad();
      render();
    }

    /* ============================================================
       RENDER
       ============================================================ */
    function renderPresets(){
      if (!presetList) return;
      presets = Array.isArray(presets) ? presets : [];
      presetList.innerHTML = "";

      for (let i=0;i<presets.length;i++){
        const p = presets[i] || { ...defaultPreset };

        const wrap = document.createElement("div");
        wrap.className = "presetBtnWrap swipeable";

        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn presetBtn";
        btn.setAttribute("data-idx", String(i));

        const name = document.createElement("span");
        name.className = "pname";

        const meta = document.createElement("span");
        meta.className = "pmeta";

        const isEmpty = (!p.workInfinite && (!p.workMs || p.workMs <= 0));
        if (isEmpty){
          name.textContent = "--:--";
          meta.textContent = "hold to save";
        } else {
          const wLabel = p.workInfinite ? "∞" : fmtMMSS_Countdown(p.workMs);
          name.textContent = wLabel;
          const r = fmtMMSS_Countdown(p.restMs || 0);
          const rounds = p.roundsInfinite ? "∞" : String(p.rounds || 0);
          meta.textContent = `rest ${r} • rounds ${rounds}`;
        }

        btn.appendChild(name);
        btn.appendChild(meta);

        // Swipe hint (only on extra presets)
        const hint = document.createElement("div");
        hint.className = "presetHint";
        hint.textContent = "SWIPE LEFT TO DELETE";

        wrap.appendChild(btn);
        wrap.appendChild(hint);
        presetList.appendChild(wrap);

        bindPresetButton(btn, i);
      }
    }

    function addPresetSlot(){
      presets = Array.isArray(presets) ? presets : [];
      presets.push({ ...defaultPreset });
      savePresets(presets);
      renderPresets();
      render();
      showToast("Preset Slot Added");
    }

    function deletePresetSlot(idx){
      if (!Array.isArray(presets) || presets.length < 1) return;
      if (idx < 0 || idx >= presets.length) return;
      presets.splice(idx, 1);
      savePresets(presets);
      renderPresets();
      render();
      showToast("Preset Deleted");
    }

    function bindPresetButton(el, idx){
      if (!el) return;

      let pressTimer = null;
      let longPressed = false;

      // swipe
      let swiping = false;
      let startX = 0;
      let startY = 0;
      let dx = 0;

      const clearPress = () => {
        if (pressTimer){ clearTimeout(pressTimer); pressTimer = null; }
      };

      const onDown = (x,y) => {
        userTapAudioPrime();
        longPressed = false;
        swiping = false;
        startX = x; startY = y;
        dx = 0;
        clearPress();
        pressTimer = setTimeout(() => {
          longPressed = true;
          savePresetAt(idx);
        }, LONG_PRESS_MS);
      };

      const movedTooFar = (x,y) => {
        const ddx = x - startX, ddy = y - startY;
        return (ddx*ddx + ddy*ddy) > (14*14);
      };

      const setTranslate = (t) => {
        el.style.transform = `translateX(${t}px)`;
      };

      el.addEventListener("pointerdown", (e) => {
        el.setPointerCapture?.(e.pointerId);
        onDown(e.clientX, e.clientY);
      });

      el.addEventListener("pointermove", (e) => {
        const x = e.clientX, y = e.clientY;
        const ddx = x - startX;
        const ddy = y - startY;

        // cancel long press if user moves
        if (pressTimer && movedTooFar(x,y)) clearPress();

        // Swipe delete (any preset)
        {
          // if the user is mostly moving horizontally, treat as swipe
          if (!swiping){
            if (Math.abs(ddx) > 18 && Math.abs(ddx) > Math.abs(ddy) * 1.2){
              swiping = true;
              clearPress();
            }
          }
          if (swiping){
            dx = Math.min(0, ddx); // only allow left swipe
            setTranslate(Math.max(dx, -140));
          }
        }
      });

      el.addEventListener("pointerup", () => {
        clearPress();

        // If swiped far enough, delete
        if (swiping && dx < -80){
          setTranslate(-140);
          // small delay for visual feedback
          setTimeout(() => deletePresetSlot(idx), 90);
          return;
        }

        // snap back
        if (swiping) setTranslate(0);

        // tap loads preset (if not long pressed)
        if (!longPressed && !swiping) applyPreset(presets[idx]);
      });

      el.addEventListener("pointercancel", () => {
        clearPress();
        if (swiping) setTranslate(0);
      });

      el.addEventListener("contextmenu", (e)=>e.preventDefault());
    }

    function syncSettingsUI(){
      if (clapVol) clapVol.value = String(settings.clapVolume);
      if (clapVolVal) clapVolVal.textContent = settings.clapVolume.toFixed(2);

      if (clapInterval) clapInterval.value = String(settings.clapInterval);
      if (clapIntervalVal) clapIntervalVal.textContent = settings.clapInterval.toFixed(2) + "s";

      if (buzzVol) buzzVol.value = String(settings.buzzVolume);
      if (buzzVolVal) buzzVolVal.textContent = settings.buzzVolume.toFixed(2);

      if (buzzDur) buzzDur.value = String(settings.buzzDurationMs);
      if (buzzDurVal) buzzDurVal.textContent = String(Math.round(settings.buzzDurationMs)) + "ms";
}

    function render(){
      // show/hide blocks
      warningsBlock?.classList.toggle("hidden", !settings.showWarnings);
      presetsBlock?.classList.toggle("hidden", !settings.showPresets);

      // Full width mode when both hidden
      const showLeft = settings.showWarnings || settings.showPresets;
      contentEl?.classList.toggle("fullWidth", !showLeft);

      // timers
      if (workDisplay) workDisplay.textContent = state.workInfinite
        ? fmtMMSS_FromSeconds(state.workElapsedSec)
        : fmtMMSS_Countdown(state.remainingWorkMs);

      if (restDisplay) restDisplay.textContent = fmtMMSS_Countdown(state.remainingRestMs);
      restDisplay?.classList.toggle("dim", state.workInfinite);

      const strikeRounds = state.workInfinite;
      document.getElementById("roundLabel")?.classList.toggle("struck", strikeRounds);
      document.getElementById("slashLabel")?.classList.toggle("struck", strikeRounds);
      roundDisplay?.classList.toggle("struck", strikeRounds);
      roundTotalDisplay?.classList.toggle("struck", strikeRounds);

      if (roundDisplay) roundDisplay.textContent = String(state.currentRound);
      if (roundTotalDisplay) roundTotalDisplay.textContent = state.roundsInfinite ? "∞" : String(state.totalRounds);

      phasePill?.classList.remove("work","rest","paused","inf");
      if (state.paused){
        phasePill?.classList.add("paused");
        if (phasePill) phasePill.textContent = "PAUSED";
      } else if (state.workInfinite){
        phasePill?.classList.add("inf");
        if (phasePill) phasePill.textContent = "INFINITE";
      } else {
        phasePill?.classList.add(state.phase === "work" ? "work" : "rest");
        if (phasePill) phasePill.textContent = state.phase === "work" ? "WORK" : "REST";
      }

      if (btnStart) btnStart.disabled = state.running && !state.paused;
      if (btnPause) btnPause.textContent = state.paused ? "Resume" : "Pause";

      toggleStartWarn?.classList.toggle("on", state.startWarnEnabled);
      toggleEndWarn?.classList.toggle("on", state.endWarnEnabled);

      modalBackdrop?.classList.toggle("show", state.keypadOpen);
      settingsBackdrop?.classList.toggle("show", state.settingsOpen);

      // top-left icon states
      toggleWarningsIcon?.classList.toggle("active", settings.showWarnings);
      togglePresetsIcon?.classList.toggle("active", settings.showPresets);

      if (state.keypadOpen) renderKeypad();
    }

    /* ============================================================
       TIMER ENGINE
       ============================================================ */
    let lastTick = 0;
    function loop(ts){
      if (!lastTick) lastTick = ts;
      const dtMs = ts - lastTick;
      lastTick = ts;

      if (state.running && !state.paused){
        step(dtMs);
      }
      requestAnimationFrame(loop);
    }

    function step(dtMs){
      if (state.workInfinite){
        state.workElapsedSec += dtMs / 1000;
        render();
        return;
      }

      if (state.phase === "work"){
        const before = state.remainingWorkMs;
        const after = Math.max(0, before - dtMs);
        state.remainingWorkMs = after;

        maybeFireWorkWarning(before, after);

        if (!state.buzzedZeroThisPhase && after === 0){
          state.buzzedZeroThisPhase = true;
          buzzer({freqHz:500});
        }

        if (after === 0){
          state.phase = "rest";
          state.remainingRestMs = state.restMs;
          resetPhaseGuards();
          checkImmediatePhaseWarnings();
        }
      } else {
        const before = state.remainingRestMs;
        const after = Math.max(0, before - dtMs);
        state.remainingRestMs = after;

        maybeFireRestWarning(before, after);

        if (!state.buzzedZeroThisPhase && after === 0){
          state.buzzedZeroThisPhase = true;
          buzzer({freqHz:500});
        }

        if (after === 0){
          state.currentRound++;

          if (!state.roundsInfinite && state.currentRound > state.totalRounds){
            resetRunState();
            render();
            return;
          }

          state.phase = "work";
          state.remainingWorkMs = state.workMs;
          resetPhaseGuards();
          checkImmediatePhaseWarnings();
        }
      }

      render();
    }

    /* ============================================================
       UI CONTROLS
       ============================================================ */    addPresetBtn?.addEventListener("click", () => { userTapAudioPrime(); addPresetSlot(); });


    btnStart?.addEventListener("click", () => {
      userTapAudioPrime();
      if (!state.running){
        state.running = true;
        state.paused = false;
        checkImmediatePhaseWarnings();
      } else {
        state.paused = false;
      }
      if (state.running && !state.paused) requestWakeLock();
      render();
    });

    btnPause?.addEventListener("click", () => {
      userTapAudioPrime();
      if (!state.running) return;
      state.paused = !state.paused;
      if (state.paused) releaseWakeLock();
      else requestWakeLock();
      render();
    });

    btnReset?.addEventListener("click", () => {
      userTapAudioPrime();
      resetRunState();
      render();
    });

    toggleStartWarn?.addEventListener("click", () => { userTapAudioPrime(); state.startWarnEnabled = !state.startWarnEnabled; render(); });
    toggleEndWarn?.addEventListener("click",   () => { userTapAudioPrime(); state.endWarnEnabled = !state.endWarnEnabled; render(); });

    setWork?.addEventListener("click", () => { userTapAudioPrime(); openKeypad("work"); });
    setRest?.addEventListener("click",  () => { userTapAudioPrime(); openKeypad("rest"); });
    setRounds?.addEventListener("click",() => { userTapAudioPrime(); openKeypad("rounds"); });

    btnStartWarn?.addEventListener("click", () => { userTapAudioPrime(); openKeypad("startWarn"); });
    btnEndWarn?.addEventListener("click",   () => { userTapAudioPrime(); openKeypad("endWarn"); });

    // Top-left icon toggles (Warnings / Presets)
    function iconKeySupport(el, onActivate){
      if (!el) return;
      el?.addEventListener("click", onActivate);
      el?.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " "){
          e.preventDefault();
          onActivate();
        }
      });
    }

    iconKeySupport(toggleWarningsIcon, () => {
      userTapAudioPrime();
      settings.showWarnings = !settings.showWarnings;
      saveSettings();
      syncSettingsUI();
      render();
    });

    iconKeySupport(togglePresetsIcon, () => {
      userTapAudioPrime();
      settings.showPresets = !settings.showPresets;
      saveSettings();
      syncSettingsUI();
      render();
    });

pad?.addEventListener("click", (e) => {
      userTapAudioPrime();
      const btn = e.target.closest("button[data-k]");
      if (!btn) return;
      const k = btn.getAttribute("data-k");
      if (/^\d$/.test(k)) keypadPushDigit(k);
      else if (k === "clear") keypadClear();
      else if (k === "infinite") keypadInfinite();
      else if (k === "cancel") closeKeypad();
      else if (k === "enter") applyKeypad();
    });

    modalBackdrop?.addEventListener("click", (e) => {
      if (e.target === e.currentTarget) closeKeypad();
    });

    /* ============================================================
       SETTINGS MODAL
       ============================================================ */
    clapVol?.addEventListener("input", () => {
      settings.clapVolume = clamp(parseFloat(clapVol.value), 0, 3);
      if (clapVolVal) clapVolVal.textContent = settings.clapVolume.toFixed(2);
      saveSettings();
    });
    clapInterval?.addEventListener("input", () => {
      settings.clapInterval = clamp(parseFloat(clapInterval.value), 0.03, 0.25);
      if (clapIntervalVal) clapIntervalVal.textContent = settings.clapInterval.toFixed(2) + "s";
      saveSettings();
    });
    buzzVol?.addEventListener("input", () => {
      settings.buzzVolume = clamp(parseFloat(buzzVol.value), 0, 1);
      if (buzzVolVal) buzzVolVal.textContent = settings.buzzVolume.toFixed(2);
      saveSettings();
    });
    buzzDur?.addEventListener("input", () => {
      settings.buzzDurationMs = clamp(parseFloat(buzzDur.value), 100, 1500);
      if (buzzDurVal) buzzDurVal.textContent = String(Math.round(settings.buzzDurationMs)) + "ms";
      saveSettings();
    });
    testClack?.addEventListener("click", () => { userTapAudioPrime(); clacksN(); });
    testBuzz?.addEventListener("click", () => { userTapAudioPrime(); buzzer({freqHz:500}); });

    openSettingsBtn?.addEventListener("click", () => {
      userTapAudioPrime();
      state.settingsOpen = true;
      syncSettingsUI();
      render();
    });
    closeSettingsBtn?.addEventListener("click", () => {
      userTapAudioPrime();
      state.settingsOpen = false;
      saveSettings();
      render();
    });
    settingsBackdrop?.addEventListener("click", (e) => {
      if (e.target === e.currentTarget){
        state.settingsOpen = false;
        saveSettings();
        render();
      }
    });

    /* ============================================================
       PRESETS
       ============================================================ */
    const LONG_PRESS_MS = 650;

    function applyPreset(p){
      if (!p) return;

      state.workInfinite = !!p.workInfinite;
      state.roundsInfinite = !!p.roundsInfinite;

      if (!state.workInfinite){
        if (!p.workMs || p.workMs <= 0) return;
        state.workMs = clamp(p.workMs, 1000, (99*60 + 59) * 1000);
      }
      state.restMs = clamp(p.restMs || 0, 0, (99*60 + 59) * 1000);

      if (!state.roundsInfinite){
        state.totalRounds = clamp(p.rounds || 1, 1, 99);
      }

      resetRunState();
      render();
      showToast("Preset Loaded");
    }

    function savePresetAt(idx){
      presets[idx] = {
        workInfinite: !!state.workInfinite,
        roundsInfinite: !!state.roundsInfinite,
        workMs: state.workMs,
        restMs: state.restMs,
        rounds: state.totalRounds
      };
      savePresets(presets);
      renderPresets();
      showToast("Preset Saved");
    }

    /* ============================================================
       INITIALIZATION
       ============================================================ */
    function resetAndRenderAll(){
      resetRunState();
      renderPresets();
      syncSettingsUI();
      render();
    }

    presets = loadPresets();
    resetAndRenderAll();
requestAnimationFrame(loop);
  </script>
</body>
</html>
